function solve(a, b) {
  // Функция рекурсии
  // i - индекс текущего символа в строке a (что ищем)
  // j - индекс текущего символа в строке b (где ищем)
  function recursion(i, j) {
    // БАЗОВЫЙ СЛУЧАЙ 1: Успех
    // Если i дошел до длины a, значит мы нашли все символы target'а
    if (i === a.length) {
      return 1;
    }

    // БАЗОВЫЙ СЛУЧАЙ 2: Провал
    // Если j дошел до конца b, но мы еще не собрали всё a (предыдущее условие не сработало)
    if (j === b.length) {
      return 0;
    }

    let count = 0;

    // ШАГ РЕКУРСИИ

    // Если символы совпадают, мы можем "взять" этот символ
    if (a[i] === b[j]) {
      // Добавляем результат ветки, где мы взяли символ (сдвигаем оба указателя)
      count += recursion(i + 1, j + 1);
    }

    // Независимо от совпадения, мы всегда можем "пропустить" текущий символ b[j]
    // и попробовать найти a[i] в оставшейся части строки b
    count += recursion(i, j + 1);

    return count;
  }

  // Запускаем рекурсию с начал строк
  return recursion(0, 0);
}

// Проверка на примере из задачи
console.log(solve("abc", "abcaacbcabc")); // 14

// Количество подпоследовательностей
// Строка a является подпоследовательностью строки b, если из b можно путем
// удаления любого количества симоволов получить a.

// Например, дана строка BABACABBACA. Строка ABCA является ее подпоследовательностью.
// Символы, помеченные ↑, оставляем, остальные вычеркиваем.

// "BABACABBACA"
//   ↑↑ ↑   ↑

console.log(solve("abc", "abcaacbcabc")); // 14

// Вот эти 14 вариантов:

// ABCaacbcabc ABcaaCbcabc ABcaacbCab
// ABcaacbcabC AbcaacBCabc AbcaacBcabC
// AbcaacbcaBC abcAacBCabc abcAacBcabC
// abcAacbcaBC abcaAcBCabc abcaAcbcaBC
// abcaAcBcabC abcaacbcABC
